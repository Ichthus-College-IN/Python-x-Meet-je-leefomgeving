% Auteur: Steven Boonstoppel, 2021-2022
% Met dank aan Nadine van der Heijden en Peter van Capel van de UU

\documentclass[a4paper,11pt, fleqn]{article}
\usepackage[dutch]{babel}
\usepackage[linkcolor=blue,colorlinks=true,urlcolor=blue]{hyperref}
%\usepackage[bookmarks=true,linkcolor=blue,colorlinks=true,urlcolor=blue,pdfborder={0 0 0}]{hyperref}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{amsmath}
\usepackage{wrapfig}
\usepackage{enumitem}
\usepackage{textcomp}
 
\include{inc/python_incl}

%\sloppy

\setlength{\topmargin}{0cm}
\setlength{\textheight}{23cm}
\setlength{\oddsidemargin}{0cm}
\setlength{\evensidemargin}{0cm}
\setlength{\textwidth}{16cm}

\pagestyle{headings}
%\numberwithin{equation}{section}

\setlength{\parindent}{0pt}
%\newcommand{\half}{ {\textstyle\frac12} }
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\interfootnotelinepenalty=10000

\newcommand{\ditwc}{Naam van het huidige werkcollege}

\title{Python dictaat H-V5}
\author{Ichthus College Veenendaal, Steven Boonstoppel}
\date{\today}

\begin{document}
\numberwithin{lstlisting}{section}
\begin{titlepage}
	{\LARGE Dictaat bij studieonderdeel:\par}
	\vspace{1cm}
	{\scshape\LARGE Imperatief programmeren\par}
	\vspace{1cm}
	{\scshape\Large PO, SE\par}
	\vspace{2cm}
	{\Huge\bfseries Python x Meet je leefomgeving\par}
	\vspace{2cm}
	{\Large\itshape 2021-2022\par}
	\vfill
	H/V5\par
	Periode 1\par
	Informatica\par
	Auteur: Boonstoppel \textsc{(bns)}\par
	\textsc{Ichthus College Veenendaal}\par
	Met dank aan: Nadine van der Heijden \& Peter van Capel
\end{titlepage}

%\maketitle
\tableofcontents

\clearpage
\renewcommand{\ditwc}{Basisvaardigheden Python}
\section[Basisvaardigheden Python]{\ditwc}
% Week 1
Ons leven bestaat bij de gratie van programmeertalen. Het versimpelt de systemen die we gebruiken, de technieken waarmee we vertrouwd zijn en het feit dat je deze tekst leest bewijst al het nut van programmeertalen.
 
Een programmeertaal die binnen \'en buiten de exacte vakken steeds meer gebruikt wordt is Python (\url{www.python.org}). Hiervoor zijn een aantal goede redenen:
\begin{itemize}
\item[-] Het is gratis en zelf aan te passen.
\item[-] Het is eenvoudig om de basis onder de knie te krijgen.
\item[-] Er zijn heel veel tutorials en voorbeelden op internet.
\item[-] Je kunt er heel veel verschillende dingen mee doen.
\end{itemize}

\begin{figure*}[h]
	\includegraphics[width=16cm]{inc/h1/github_languages.png}
	\caption{\it De meest populaire programmeertalen in de periode 2014-2021. Python is de tweede meest populaire taal, goed voor een zesde van alle (openbare) scripts ter wereld. \textit{Bron: GitHub}}
	\label{github-languages}
\end{figure*}

In deze periode komen de meest nuttige eigenschappen van Python aan de orde. Als je het begint te begrijpen, ga je de lol van programmeren vanzelf inzien. Maar zoals je eerst letters moet leren voordat je kunt lezen, moeten we beginnen met de wat taaiere kost waarvan het nut later duidelijk wordt: hoe maak en bewerk je een script, wat zijn datatypes, functies, variabelen, etc.

\subsection{Python scripts schrijven en uitvoeren in Spyder}
We gebruiken op het Ichthus het programma Spyder om in te programmeren. De interface van Spyder wordt weergegeven in Figuur \ref{fig-spyder}. Deze bestaat standaard uit \'e\'en window met drie schermen: de Editor, Variable explorer en Console. Elk van deze heeft zijn eigen functie:
\begin{itemize}
\item[-] Het scherm links is de Editor. Hierin schrijf je de Python code, ook wel script genoemd, die een berekening of taak uitvoert. 
\item[-] De Explorer rechtsboven heeft vier tabbladen. Tab `Files' laat je scripts zien. In de Tab `Variable Explorer' wordt de waarde van de bestaande variabelen weergegeven nadat je een script hebt uitgevoerd. Alle figuren verschijnen in de Explorer onder de lab `Plots'. Tot slot geeft de `Help' tab je een mogelijkheid om snel de eigenschappen van een functie op te zoeken.
\item[-] De Console rechtsonder is het gedeelte waarin informatie over het runnen (of \textit{draaien}) van je script verschijnt. Ook de uitvoer (\textit{output}) komt hier terecht.
\end{itemize}

\begin{figure*}[h]
\includegraphics[width=16cm]{inc/h1/spyder_screenshot.png}
\caption{\it De interface van Spyder direct na het opstarten van het programma.}
\label{fig-spyder}
\end{figure*}

\subsubsection*{Oefenopdracht: Hello World} 
\begin{itemize}
	\item Typ de volgende regel tekst in de Editor (niet kopi\"eren vanuit de pdf!): 
	\begin{python}
print('Hello, world!')
	\end{python}
	Sla je bestanden met een duidelijke naam op in jouw GitHub map. Dit betekent dat de naam van de opgeslagen bestanden duidelijk maakt wat het script doet, of waar het onderdeel van is. Je kunt het beste alleen letters, cijfers en eventueel normale (-) of liggende (\_) streepjes (geen spaties!) te gebruiken. Sla je bestand op met bijvoorbeeld de naam \verb,h1_1-helloworld.py,.
	\item Run het script.  Dat doe je door op de groene play-knop in de balk bovenin te klikken (of de F5-toets in te drukken). Klik vervolgens (eenmalig) op Run.\\
	{\bf Vraag:} Wat is de functie van het commando \pythoninline{print()}? Kijk hiervoor in de console rechtsonderin.
	\item Pas de tekst tussen de apostrofs aan naar je eigen naam en zorg dat je daardoor in de Console jouw naam tevoorschijn krijgt.
\end{itemize}

Kopie\"{e}r \textbf{nooit} stukjes tekst uit de .pdf file die je nu leest, want dan krijg je vaak verminkte bestanden waaraan je onnodig veel tijd moet besteden om ze te repareren. Typ het over als het kort is, of klik op de hyperlink als die boven een stuk code staat en kopieer vanaf het GitHub bestand.

\subsection{Eenvoudige rekenkundige operaties}
Met Python kun je makkelijk rekenen. Hiervoor gebruik je normale tekens: optellen (\pythoninline{+}), aftrekken (\pythoninline{-}), vermenigvuldigen (\pythoninline{*}), delen (\pythoninline{/}) en (let op!) machtsverheffen (\pythoninline{**}).

\begin{python}
1 + 1
2 - 2
3*3
4/4
5**5
\end{python}

Tip: Het is onder Python programmeurs gebruikelijk om een spatie te typen voor en na een plus of min-teken, maar niet bij vermenigvuldigen, delen of machtsverheffen. Dit legt nadruk op de rekenregels. Bijvoorbeeld: 

\begin{python}
print(1 + 2 - 3*4**5)
\end{python}
\textbf{Vraag:} wat gebeurt er als je alleen de som berekent zonder \pythoninline{print()}?

\subsubsection*{Oefenopdracht: Python als rekenmachine} 
\begin{itemize}
	\item Bereken de hoogte $y$ van een softbal die vanaf de grond omhoog wordt geslagen met een beginsnelheid van $v_0 = 25 \, {\rm m/s}$ op $t = 2 \, {\rm s}$ aan de hand van de formule:
	\begin{equation}
	y = v_0 t - \frac{1}{2}g t^2
	\end{equation}
	De zwaartekracht $g = 9.81 \, {\rm m/s}^2$. Maak gebruik van bovenstaande formule en vul de getallen in. Let op: komma-getallen noteer je in het Engels met een punt (dus het is echt 9 punt 81). Het goede antwoord is 30.38 meter.
\end{itemize}


\subsection{Variabelen}
Net als wiskunde `op papier' is het handig om van variabelen als letters gebruik te maken in plaats van de getallen gelijk in te vullen. Dit is ook zo bij programmeren en zorgt voor overzicht als je scripts langer en moeilijker worden.

Bij de vorige oefenopdracht moet je meerdere getallen aanpassen als je het tijdstip verandert. Maar veel handiger en sneller is het gebruik van {\it variabelen} in Python. Let op de volgorde waarin je de variabelen en de formule in je code opschrijft. Een script wordt (best logisch) van boven naar beneden uitgevoerd. Om berekeningen te kunnen doen met variabelen, moeten deze eerst gedefini\"eerd worden. Anders krijg je errors.

\begin{python}
a = 1
b = 2
c = 3
x = 1
y = a*x**2 + b*x + c
print(y)
\end{python}

Namen voor variabelen kun je zelf kiezen. De enige voorwaarden zijn dat de namen moeten beginnen met een letter, en geen spatie of wiskundig teken mogen bevatten. Kies voor een variabele altijd een naam die past bij de betekenis ervan in jouw script. Noem een lijst van temperaturen bijvoorbeeld \pythoninline{temp} of \pythoninline{temperatuur}.

\subsubsection*{Oefenopdracht: Gebruik van variabelen} 
\begin{itemize}
	\item Bereken opnieuw de hoogte van de bal uit de vorige opdracht. Doe dit nu voor $t = 0,1,2,3, ... $ en geef een grove schatting hoe lang het duurt voordat de bal weer op de grond is. Nu maak je uiteraard gebruik van variabelen zoals hiervoor beschreven!
\end{itemize}

\subsection{Commentaar}
Vaak is het voor een buitenstaander een raadsel wat een variabele betekent als hij het script niet kent. 
Dit is \'e\'en van de redenen om in een script \textit{commentaar} toe te voegen. (Kies daarnaast dus ook nuttige namen voor je variabelen!)
Het meest eenvoudig is het om hiervoor de hashtag te gebruiken, want alle tekst op een regel na \pythoninline{#} wordt genegeerd bij het runnen van een script. 

De formule voor het vermogen van een apparaat kan bijvoorbeeld op de volgende manier verduidelijkt worden:
\begin{python}
# vermogen van de wasmachine
U = 230	   # spanning van het lichtnet in V
I = 2      # stroomsterkte over het apparaat in A
P = U*I    # formule voor het vermogen
print(P)
\end{python}

Het werkt erg fijn om bij een aantal regels onder elkaar het commentaar altijd op dezelfde 'lijn' te zetten: wel zo overzichtelijk. Dat zul je in alle komende voorbeelden ook tegenkomen.

Als je in Spyder een nieuw Python script aanmaakt zie je direct nog een andere manier om commentaar te schrijven. Alle tekst tussen \verb,""", en de volgende \verb,""", is commentaar; deze manier van commentaar aangeven is handig voor grotere stukken tekst. 

\subsubsection*{Oefenopdracht: Commentaar schrijven}
\begin{itemize}
	\item Voeg bij de oefenopdracht van de vorige paragraaf commentaar toe aan je script. Geef bijvoorbeeld de eenheden weer van de getallen.
\end{itemize}

\subsection{Datatypen}
In alle bovenstaande opdrachten zijn de variabelen hele getallen. Daarnaast kun je gebruik maken van stukken tekst, kommagetallen of \pythoninline{True/False}. Dat zijn allemaal {\it datatypen}. Ter informatie zijn hieronder de meest gebruikte, met hun offici\"ele naam:

\begin{description}
\item[\textbf{int}] Gehele getallen: \pythoninline{3  300  20}

In Python (en andere programmeertalen) is {\bf int} het datatype dat gebruikt wordt voor gehele getallen. Zie bovenstaand voorbeeld (\pythoninline{a = 1} etc). Je kunt ook een kommagetal gebruiken, maar let op: dit is niet hetzelfde als afronden op gehele getallen! \pythoninline{int(3.9) = 3} en niet een afgeronde 4. Alle getallen achter de punt worden 'weggegooid'.

\item[\textbf{float}] Getallen met decimalen: \pythoninline{2.3  4.62  100.00}

Het datatype voor decimale getallen is {\bf float}. Floats maak je door een getal met een decimale punt te maken, zoals: \pythoninline{a = 1.5}. Het getal \pythoninline{1.} is hetzelfde als \pythoninline{1.00000000}

\item[\textbf{bool}] Logische waarde: \pythoninline{True} of \pythoninline{False}

Een {\bf boolean} type, dat we later in het hoofdstuk zullen tegenkomen, is een binair datatype dat twee waarden kan hebben: \pythoninline{True} of \pythoninline{False}.

\item[\textbf{str}] Geordende reeks karakters (tekst): \pythoninline{'hello'  'Sam'  "2019"}

Een {\bf string} is het datatype voor tekst. Deze heb je ongemerkt gebruikt in \pythoninline{'Hello world!'}, met \pythoninline{print()}. Om in Python een \pythoninline{string} te maken gebruik je aanhalingstekens. \pythoninline{a = 'tekst'} en \pythoninline{a = "tekst"} zijn allebei toegestaan.

\end{description}

Je kunt het datatype van een variabele altijd bekijken in de Variable Explorer, als dat nodig is.

\subsection{Loops}
Binnen Python bestaan manieren om functies of handelingen automatisch en/of heel vaak uit te voeren. We behandelen hier de constructies \pythoninline{while} en \pythoninline{if}.

\subsubsection{Boolean expressions}
In de voorbeelden van loops hieronder gaan we gebruik maken van voorwaarden om delen van scripts wel of niet uit te voeren. De algemene term voor deze voorwaarde is \textit{Boolean expression}. De uitkomst van zo'n conditie heeft twee mogelijkheden, namelijk \pythoninline{True} of \pythoninline{False}. Vaak wordt zo'n voorwaarde ook wel een test genoemd.

\begin{python}
a == b	# test of a gelijk is aan b (let op dubbel = teken!)
a != b	# test of a niet gelijk is aan b
a > b	# test of a groter is dan b
a >= b	# test of a groter dan of gelijk is aan b
a < b	# test of a kleiner is dan b
a <= b	# test of a kleiner dan of gelijk is aan b
\end{python}

Daarnaast kunnen Boolean expressions ook worden gecombineerd door het gebruik van \pythoninline{and} waarbij de formule alleen  \pythoninline{True} zal opleveren als aan beide voorwaarden wordt voldaan; of \pythoninline{or} waarbij de formule \pythoninline{True} zal opleveren als aan minstens \'e\'en van de twee condities wordt voldaan (beide mag dus ook).

\begin{python}
a > b and c < d
a > b or c < d
\end{python}

\subsubsection{While}
Een zogenaamde \pythoninline{while} loop gebruik je om een bepaald stuk code te herhalen zolang er aan een voorwaarde voldaan wordt. Voor het voorbeeld van de omhoog geslagen bal dat we eerder gebruikt hebben kunnen we de hoogte van de bal berekenen zolang die in de lucht is. Hoe zo'n loop kan worden ge\"implementeerd is te zien in onderstaand voorbeeld.

\pythonexternal{inc/h1/while_vb1.py}

Net als eerder defini\"eren we de benodigde variabelen $v_0$ en $g$. Daarnaast maken we een variabele aan voor de tijd $t$ en kiezen we de grootte van de tijdstappen $dt$ die we willen maken voor $t$. Zolang (\textit{while}) $y \geq 0$ printen we $t$ en $y$, wordt de nieuwe hoogte $y$ berekend en gaan we een tijdstap verder.

Zolang $y \geq 0$ wordt aan de voorwaarde voldaan en wordt de code in de functie van de \pythoninline{while} uitgevoerd. Alle regels die horen bij de \pythoninline{while}-loop worden dan uitgevoerd. Welke regels er binnen de loop horen is te zien aan de {\it tab} voor de regels: elke regel begint met zo'n \textit{indent} om aan te geven dat die regels onderdeel zijn van deze loop.

Een veelvoorkomende fout bij een \pythoninline{while}-loop is dat de voorwaarde altijd \pythoninline{True} blijft, waardoor het script oneindig doorgaat. Dit gebeurt bijvoorbeeld als $y$ nooit kleiner wordt dan 0, of als je de regel \pythoninline{t = t + dt} vergeet of verkeerd invoert zoals de indent vergeten. Je kunt een script stoppen in Spyder door op de rode knop rechts boven in de Console te drukken.

\subsubsection*{Oefenopdracht: Gebruik van een while-loop}
\begin{itemize}
	\item Klik op de hyperlink boven bovenstaand voorbeeld, kopieer het script vanuit de webpagina en voer het uit in Spyder. Op welk tijdstip komt de bal weer op de grond? Verklein ook de tijdstap $dt$ om zo een nauwkeuriger antwoord te vinden.
	\item Maak een script waarin de getallen 1 t/m 100 worden geprint met behulp van een \pythoninline{while}-loop.
\end{itemize}

\subsubsection{If}
Een tweede soort constructie is de zogenaamde \textit{if - else} constructie. Aan de hand van een voorwaarde wordt een bepaald deel code wel of niet uitgevoerd. Een variant hierop is de \textit{if - else if - else} constructie, waarbij er meer dan 2 mogelijkheden voorkomen. Je kunt zoveel \pythoninline{elif}'s toevoegen als je wilt.

Let op: ook hier gebruik je \textit{indents}. In Python wordt \textit{else if} afgekort tot \pythoninline{elif}. 

\begin{python}
if gewicht < 40:            # 0 - 39.99999999 kg
    print("Ondergewicht!")
elif gewicht < 80:          # 40 - 79.99999999 kg
    print("Goed gewicht")
else:                       # 80 kg en meer
    print("Overgewicht!")
\end{python}

\pythoninline{else} heeft {\it nooit} een voorwaarde! 'Anders' zijn alle overige opties, zonder een voorwaarde. Wil je een voorwaarde gebruiken, dan moet je \pythoninline{elif} gebruiken.


\subsubsection*{Oefenopdracht: Testen van combinaties van Boolean expressions} 
\begin{itemize}
	\item Typ het voorbeeld hierboven over en test het uit door het script compleet te maken. 
	\item Voeg naast gewicht nog een voorwaarde toe: lengte. Je hebt alleen ondergewicht bij 40 kilo als je langer bent dan een bepaald aantal centimeter. Bedenk er zelf maar wat van, maar test je functie ook! Maak gebruik van paragraaf 1.6.1.
\end{itemize}

\subsubsection{For}
Als je een functie een exact aantal keer wilt uitvoeren kun je dit met een \pythoninline{while}- of \pythoninline{if}-loop doen waarin je een teller zet. Bijvoorbeeld:
\begin{python}
i=0
while i < 5:
    print(i)
    i=i+1
\end{python}
Een handigere manier om dit te doen is met een \pythoninline{for}-loop. Hierbij zit de `teller' automatisch ingebouwd: de loop wordt herhaald voor elk element in de voorwaarde. Elke \pythoninline{while}-loop is om te schrijven in een \pythoninline{for}-loop, maar soms \textit{voelt} de \'e\'en logischer, en is die ook makkelijker. Maar gebruik waar mogelijk een \pythoninline{for}-loop. Dit voorbeeld is toch best wat korter en simpeler:

\begin{python}
for i in range(5):
    print(i)
\end{python}

\subsubsection*{Oefenopdracht: for i in range()}
\begin{itemize}
	\item Voer het voorgaande stukje code uit. \\
	\textbf{Vraag:} welke getallen zitten er verborgen in \pythoninline{range(5)}? En wat als je er \pythoninline{range(10)} van maakt?
\end{itemize}

Je kunt in de \pythoninline{range}-functie \'e\'en, twee of drie getallen invullen. Zie onderstaande opties:
\begin{python}
range(5)        # ziet eruit als [ 0, 1, 2, 3, 4 ] 
                # oftewel: van 0 TOT 5 (begint standaard bij 0)
range(2,8)      # ziet eruit als [ 2, 3, 4, 5, 6, 7 ] 
                # oftewel: van 2 TOT 8
range(10,42,5)  # ziet eruit als [ 10, 15, 20, 25, 30, 35, 40 ]
                # oftewel: van 10 TOT 42 met stappen van 5
\end{python}

\subsubsection*{Oefenopdracht: for i in range()}
\begin{itemize}
	\item Print voor elk derde getal tussen 10 en 100 het getal, en de wortel van dat getal. Tip: $\sqrt{x} = x^{0.5}$.
\end{itemize}

\subsection{Slotopdrachten}
{\it Voor alle opdrachten geldt dat je wordt aangemoedigd om op het internet te zoeken in de enorme hoeveelheid voorbeelden, tutorials, vragen en antwoorden over het gebruik van Python. Maak daar vooral gebruik van! Voor alle opdrachten geldt ook: maak je eigen script, en sla dat op met het nodige commentaar zodat je het later misschien kunt hergebruiken of je medeleerlingen er blij mee kunt maken.}

\subsubsection{Slotopdracht 1: Wortels trekken} 

Schrijf een Python-script dat aan jou als gebruiker om input vraagt en vervolgens wel of niet een wortel trekt, om daarna weer een nieuw getal te vragen etc.

\begin{itemize}
	\item Allereerst vragen we de gebruiker om input. Zie daarvoor onderstaande regel. Als je het script uitvoert met deze regel, kun je rechtsonder in de console klikken en achter de tekst een getal invullen. Als je op Enter drukt wordt je getal opgeslagen in de variabele \pythoninline{invoer}.
	\item Deze input is van het datatype \pythoninline{str} (string, ofwel tekst). Van tekst kun je geen wortel trekken, dus moet \pythoninline{invoer} eerst omgezet worden in een getal (\pythoninline{int}). Kijk in paragraaf 1.5 of zoek op internet een methode om van de input een \pythoninline{int} te maken, en sla dit getal op in een nieuwe variabele.
	\item Maak vervolgens een \pythoninline{while}-loop. Deze loop moet stoppen als het ingevoerde getal gelijk is aan 0.
	\item Check vervolgens in de loop of het getal groter is dan nul of kleiner. Als het opgegeven getal inderdaad positief is wordt de wortel van dat getal geprint. Is het opgegeven getal negatief, dan wordt de wortel niet uitgerekend. Je print dan de tekst \verb."Dombo: Positief svp!"..
	\item Vraag vervolgens nog steeds in de loop (heel beleefd) weer om een positief getal. Gebruik de regels waarmee je voor het eerst om input vraagt hier gewoon opnieuw!
\end{itemize}

\begin{python}
invoer = input("Geef een positief getal: ")  # input heeft datatype string
\end{python}

\subsubsection{Slotopdracht 2: Omrekenen van Fahrenheit naar Celsius}
Schrijf een script dat voor de temperaturen van -10 tot en met 100 Fahrenheit met stappen van 5 Fahrenheit de temperatuur in graden Celsius berekent. Print voor elke 5 Fahrenheit de temperatuur in Fahrenheit, de berekende temperatuur in Celsius, en de conclusie of het wel of niet vriest. (Hint: controleer dus of de temperatuur in graden Celsius kleiner of groter dan 0 is!)

De conversie tussen Celsius en Fahrenheit is
\begin{equation}
C = \frac{5}{9}(F - 32)
\end{equation}

\clearpage
\renewcommand{\ditwc}{Modules (1): NumPy}
\section[Modules (1): NumPy]{\ditwc}
% Week 2
In dit hoofdstuk kijken we naar een essentieel onderdeel van het programmeren in Python: het gebruik van {\it modules}. Modules bevatten functionaliteit die niet in Python zelf zit maar apart toegevoegd moet worden. Oorspronkelijk kon je met Python niet veel meer dan stukken tekst bewerken. In dit hoofdstuk behandelen we \pythoninline{numpy}, dat het makkelijk maakt om met getallen en data te werken.

Het importeren van een module gebeurt (gewoonlijk op de eerste regel(s) van je script) met het commando \pythoninline{import}. Het is gebruikelijk om \pythoninline{numpy} af te korten tot \pythoninline{np}. Dat ziet er in de praktijk zo uit: 
\begin{python}
import numpy as np
\end{python}
Vanaf dit punt wordt naar \pythoninline{numpy} verwezen als \pythoninline{np}. Om functies uit een module te gebruiken wordt de afkorting van de module als voorvoegsel gebruikt, gevolgd door een punt, en dan het commando(= de naam van de functie) uit de module.\\
Bijvoorbeeld: \pythoninline{np.sin(X) # berekent de sinus van X}.

\subsection{Arrays maken}
Een {\it array} (Nederlands: reeks) is een verzameling van getallen. In Python kun je die maken als een offici\"ele Python lijst, maar zo'n lijst is erg onhandig. In plaats daarvan gebruiken we veel liever een numpy array, zodat we met alle standaard numpy functies kunnen werken.

De duidelijkste manier om een array te maken is met de functie \pythoninline{np.array()}. Als je de getallen van de dobbelsteen in een array wilt zetten, doe je dat bijvoorbeeld zo:
\begin{python}
getallen_array = np.array([1,2,3,4,5,6]) 
# let op de extra blokhaken [] tussen de ronde haken ()
\end{python}

Hieronder een kort overzichtje van nuttige manieren om een (automatisch) array te maken.

\pythonexternal{inc/h2/np_vb1.py}

Merk op dat \pythoninline{np.arange()} het eindgetal (\pythoninline{5.}) niet meeneemt, \pythoninline{np.linspace()} doet dit wel, dus \pythoninline{grid1} en \pythoninline{grid2} zijn verschillend. 

\subsubsection*{Oefenopdracht: Maken en bewerken van numpy arrays}
\begin{itemize}
	\item[a)] Schrijf een script waarmee een array wordt gemaakt met daarin de getallen 1.5 tot en met en 3.0 met stappen van 0.3. Doe dit met zowel \pythoninline{np.arange} als \pythoninline{np.linspace}. Controleer je resultaten door beide arrays te printen.
\end{itemize}

\subsection{Rekenen met arrays}
Rekenen met arrays is super makkelijk. Wanneer twee arrays dezelfde vorm (evenveel getallen) hebben, kun je ze getal voor getal optellen door \pythoninline{+} te gebruiken. Wanneer deze niet dezelfde vorm hebben krijg je een foutmelding. Alle wiskundige formules (\pythoninline{+,-,/,*,**}) werken op deze manier.

Neem het volgende voorbeeld maar over en zie wat er gebeurt:
\begin{python}
a = np.array([1,2,3,4,5])
b = np.array([6,7,8,9,10])
c = a + b
print("c: ", c)
d = a * b
print("d: ", d)
\end{python}

\subsubsection*{Oefenopdracht: Maken en bewerken van numpy arrays}
\begin{itemize}
	\item[b)] Maak een array met behulp van \pythoninline{np.linspace()} met de naam $k$ met daarin de gehele getallen van 1 tot en met 10. Bereken vervolgens $k^k$. Print en controleer de resultaten daarvan. Valt je iets op?\footnote{Als er iets niet klopt, geef het aan bij de docent! Die legt het wel uit :)}
\end{itemize}

\subsection{Indexing en slicing}
Soms is het fijn om losse getallen of delen van een array te selecteren. In het codeblok hieronder is te zien hoe je een enkel element uit een array kunt selecteren {(\it indexing} of een groter deel van de array {\it slicing}). 

\pythonexternal{inc/h2/np_vb2.py}

\subsubsection*{Oefenopdracht: Maken en bewerken van numpy arrays}
\begin{itemize}
	\item[c)] Vraag: wat is de waarde van \pythoninline{test_array[1]}? Let goed op!
	\item[d)] Print met behulp van een for-loop elk getal in \pythoninline{test_array}. Kijk eventueel terug naar hoofdstuk 1.
	\item[e)] Pas bovenstaande loop zodanig aan dat je niet elke keer \'e\'en getal print, maar het `huidige' \'en vorige getal. Zorg dat je dit goed kunt, want dat helpt bij de slotopdracht straks!
\end{itemize}

\subsection{Allerlei functies}
Numpy arrays hebben een aantal ingebouwde functies, om bijvoorbeeld het gemiddelde of de som uit te rekenen. Dat kan door \pythoninline{np.functie(array)} te gebruiken. Daarnaast nog een standaard Python functie om het aantal elementen in een array weer te geven.

\pythonexternal{inc/h2/np_vb3.py}

\subsubsection*{Oefenopdracht: Maken en bewerken van numpy arrays}
\begin{itemize}
	\item[f)] Bereken het gemiddelde van het $k^k$-array van oefenopgave b).
\end{itemize}

\subsection{Maskers}
In sommige gevallen wil je een lijst getallen filteren. Je bent bijvoorbeeld ge\"interesseerd in alle leeftijden boven de 18 jaar, of alle leerlingen in de bovenbouw. Dit kan aan de hand van een {\it masker}. De werking van zo'n masker wordt uitgelegd aan de hand van het onderstaande voorbeeld\footnote{In de .pdf zie je dat diverse Python woorden blauw gekleurd zijn; ook als er in een stukje tekst toevallig een Python woord staat, zoals in masker. Een klein foutje waar ik helaas niet veel aan kan doen.}.
Een masker maak je door een voorwaarde op te geven bij een variabele. Alle plekken in de array die voldoen aan die voorwaarde, geven de waarde \pythoninline{True}, alle anderen geven \pythoninline{False}. Een masker pas je vervolgens toe met de blokhaken \pythoninline{[ ]}.

\pythonexternal{inc/h2/np_vb4.py}

\subsubsection*{Oefenopdracht: Maken en bewerken van numpy arrays}
\begin{itemize}
	\item[g)] Selecteer met behulp van een masker alle oneven getallen uit \pythoninline{test_array} van bovenstaand voorbeeld. Hiervoor kun je goed gebruik maken van de rest-berekening, die je jaren geleden wel eens gezien hebt. Zie dit voorbeeld:
	\begin{python}
# rest(4/2) is 0 (2 past precies 2 keer in 4)
print(4 % 2) # dit print rest(4/2) oftewel 0

# rest(5/2) is 1 (2 past 2 keer in 5, en er blijft 1 over)
print(5 % 2) # dit print rest(5/2), oftewel 1
	\end{python}
	In plaats van een test of de getallen groter zijn dan 5 (zoals in het bestand boven de opdracht), test je hier dus of de rest gelijk is aan 1! Want elk oneven getal gedeeld door 2 levert een rest van 1 op.\\
	Print als laatste ter controle het array met dit masker, zodat je alleen de oneven getallen ziet.
\end{itemize}

\iffalse
\subsection{For-loops}
In paragraaf 1.5 is de \pythoninline{for}-loop aan de orde gekomen. Hier komt nu geen nieuwe stof bij, maar in het licht van numpy-array's is het goed om nog een oefenopdracht te maken. Deze helpt ook bij de slotopdracht. Bekijk en run eerst dit voorbeeld:

\begin{python}
data = np.array([1,2,3,4,5,6]) # een test array

# De volgende for-loop print een voor een alle getallen in 'data'
# 'i' is hierbij het getal dat loopt van 0 tot len(data) = 6
for i in range(len(data)):
    print(data[i])
\end{python}

\subsubsection*{Oefenopdracht: for-loops en numpy-arrays}
\begin{itemize}
	\item Maak een array \pythoninline{np.linspace(0,10,num=20)}. Dit zijn dus 20 getallen, oplopend van 0 naar 10.
	\item Maak vervolgens, net als in het voorbeeld, een \pythoninline{for}-loop met dezelfde print-regel.
	\item Pas dit vervolgens zo aan, dat je niet elke keer \pythoninline{data[i]} print, maar alle getallen vanaf de eerste plek tot de huidige plek (plek i). De eerste keer print dat alleen lege haken (\pythoninline{[]}), de tweede keer \'e\'en getal, de derde keer twee, etc.
	\item Print vervolgens het gemiddelde van die getallen. (De eerste keer is dat dus het gemiddelde van nul getallen: dit levert een waarschuwing op maar geen error. De tweede keer is dat het gemiddelde van \'e\'en getal, de derde keer van twee getallen, etc.)
	\item Controleer je loop: het laatste gemiddelde is het gemiddelde van alle getallen behalve de laatste. Dat is dus 4.75.
\end{itemize}
\fi

\subsection{Slotopdracht: Voortschrijdend gemiddelde}
Tijdens de corona pandemie hebben we eindeloos veel grafiekjes gezien van het aantal besmettingen per dag. In het weekend is dat altijd lager, en door de weeks juist weer hoger. Het is daarom nuttiger om naar het gemiddelde van de afgelopen zeven dagen te kijken: dan compenseer je de uitschieters een beetje. Dit gemiddelde noemen we het {\it voortschrijdend gemiddelde}: voor elke dag bereken je het gemiddelde van de zeven dagen daarvoor. Je kunt over de eerste 7 dagen geen voortschrijdend gemiddelde berekenen: er zijn immers nog geen volledige zeven dagen geweest.

In deze slotopdracht maak je zelf een voortschrijdend gemiddelde.

\begin{itemize}
	\item Maak een array genaamd \pythoninline{random_array} van 50 random getallen tussen de 0 en 1 (zoek hiervoor in het hoofdstuk).
	\item Maak een variabele genaamd \pythoninline{periode}, met de waarde 7. Dit is het aantal dagen waarover we het gemiddelde gaan berekenen.
	\item Maak vervolgens een \pythoninline{for}-loop. Deze start op de dag n\'a de periode, tot en met de laatste waarde van je array. (Hint: \pythoninline{range(periode,len(random_array))})
	\item Bereken per element in de \pythoninline{for}-loop het gemiddelde van de afgelopen 'periode' dagen. Print elke keer het berekende gemiddelde van de afgelopen 7 dagen.
	\item Wat valt je op als je de periode verhoogt (naar bijvoorbeeld 30)?
\end{itemize}

\clearpage
\renewcommand{\ditwc}{Modules(2): MATPlotLib}
\section{Modules (2): MATPlotLib}
%Week 3
In dit deel bekijken we hoe we data kunnen visualiseren: zichtbaar maken in grafieken. We gebruiken hiervoor het \pythoninline{pyplot} onderdeel uit het pakket \pythoninline{matplotlib} (MATLab Plotting Library). Het importeren werkt vergelijkbaar als bij \pythoninline{numpy}:
\begin{python}
import matplotlib.pyplot as plt
\end{python}

In dit hoofdstuk staan voor de verschillende mogelijke varianten voorbeelden. Van de variant in paragraaf 3.1 wordt verwacht dat je ze zelf uit je hoofd kunt maken later, maar de varianten in 3.3 en 3.4 kun je uiteraard gewoon elke keer kopi\"eren bij latere opdrachten.

\subsection{E\'en grafiek maken}
Een grafiek maken in Python hoeft maar een paar regeltjes te kosten. We hebben nodig: een x-as, een formule voor $y$, en een plaatje om het in te maken. In het onderstaande voorbeeld maken we een array aan voor de x-as: dit is het domein van de grafiek. We kiezen deze van $0$ tot $2\pi$. Vervolgens gaan we daar een lijn bij maken, in formulevorm: $y = sin(x)$. Python kent zelf geen sinus, dus moeten we gebruik maken van NumPy om de sinus te kunnen berekenen.

Vervolgens maken we een figuur aan. Dat gebeurt in de regel \pythoninline{fig, ax = plt.subplots()}. \pythoninline{fig} is hierbij de `omschrijving' van de `buitenkant' van het plaatje, terwijl \pythoninline{ax} over de `binnenkant' van het plaatje gaat, oftewel je grafiek. Daarna gaan we de sinus tekenen ofwel {\it plotten}:

\pythonexternal{inc/h3/plt_vb1.py}

\subsubsection*{Oefenopdracht: lijnen plotten}
\begin{itemize}
	\item[a)] Kopieer via de hyperlink het bovenstaande voorbeeld en voer het script uit. Let op: er verschijnt rechtsonderin een waarschuwing; deze mag je negeren. Rechtsbovenin zie je twee plaatjes verschijnen.
	
	\item[b)] Verander het aantal elementen in \pythoninline{x}. Wat gebeurt er als het aantal elementen in de lijst klein is (bijvoorbeeld 10)?

	\item[c)] Verander het tweede plaatje zo dat er geen $y^2$ wordt geplot, maar dat er een cosinus wordt geplot. \\
	{\bf Hint:} \pythoninline{y2 = np.cos(x)}

	\item[d)] Maak een extra plaatje door in hetzelfde script nog een keer \pythoninline{fig, ax = plt.subplots()} toe te voegen. Plot in dit plaatje \pythoninline{y} en \pythoninline{y2} tegen elkaar. Dit betekent dat je in plaats van \pythoninline{ax.plot(x,y)} invult: \pythoninline{ax.plot(y,y2)}.
\end{itemize}

\subsection{Grafieken opmaken}
Een kale grafiek is niet zo nuttig. Daarom is er ook heel veel opmaak mogelijk in matplotlib. Hieronder zijn een flink aantal opties:

\begin{itemize}
	\setlength\itemsep{0em}
	\item \pythoninline{ax.set_title("titel")}: voeg een titel toe aan de grafiek.
	\item \pythoninline{ax.set_xlabel("x-label")}: voeg een titel toe aan de x-as.
	\item \pythoninline{ax.set_ylabel("y-label")}: voeg een titel toe aan de y-as.
	\item \pythoninline{ax.set_xlim(x_min, x_max)}: pas het domein van de x-as aan van {\it x\_min} tot {\it x\_max}.
	\item \pythoninline{ax.set_ylim(y_min, y_max)}: pas het bereik van de y-as aan van {\it y\_min} tot {\it y\_max}.
	\item \pythoninline{ax.grid()}: voeg een raster toe aan de grafiek om beter af te kunnen lezen.
	\item \pythoninline{ax.plot(x,y,label="label")}: voeg een label toe aan de lijn.
	\item \pythoninline{ax.legend()}: voeg een legenda toe die alle labels toont.
	\item \pythoninline{ax.set_aspect(1)}: stel de verhouding van de assen in. Als beide assen lopen van 0 tot 1 (of andere dezelfde getallen) krijg je bijvoorbeeld een vierkant plaatje (verhouding 1:1 = 1).
\end{itemize}

Daarnaast kun je ook de punten of lijnen in je grafiek opmaken. Je kunt de kleur kiezen door tijdens het plotten een letter in te vullen; als je dat niet doet maakt matplotlib automatisch een ander kleurtje. Je kunt de stijl kiezen door \'e\'en of twee tekens toe te voegen; als je dat niet doet maakt matplotlib automatisch een lijn tussen de punten.

De standaardkleuren zijn:
\begin{python}
# b: blauw         # m: magenta      # c: cyaan
# g: groen         # y: geel         # w: wit
# r: rood          # k: zwart
\end{python}

De standaardstijlen zijn:
\begin{python}
#--: gestreepte lijn                 # .: punten
# o:  grote punten                   # -:  lijn
#-.: afwisselend lijn/punt
\end{python}

In onderstaande oefenopdracht zie je hoe je deze kleuren en stijlen kunt gebruiken.

\subsubsection*{Oefenopdracht: grafieken opmaken}
\begin{itemize}
	\item[e)] We bekijken de volgende simulatie: de Spaanse KNMI heeft sinds 1981 de warmste temperatuur per jaar bijgehouden in Madrid. Een medewerker van het instituut heeft een plotje gemaakt van die data; zie het bestand onder de volgende oefenopgave. \\
	Zijn leidinggevende heeft de volgende eisen gesteld: de figuur moet een algemene titel en twee astitels krijgen. Het domein moet vallen van 1981 tot 2021; het bereik van 40 tot 45 graden Celsius. Daarnaast moeten de meetpunten en de trendlijn aangegeven worden in een legenda, en moet de grafiek goed uit te lezen zijn. Vul het script aan met bovenstaande opties zodat aan de voorwaarden wordt voldaan.
	
	\item[f)] Maak de volgende plot: kies $t$ van $0$ tot $2\pi$. Gebruik: \\
	\pythoninline{x = 16*np.sin(t)**3}\\
	\pythoninline{y = 13*np.cos(t) - 5*np.cos(2*t) - 2*np.cos(3*t) - np.cos(4*t)}\\
	 Zorg voor een goede verhouding tussen de assen (1:1).\\
	 {\bf Tip:} maak gebruik van het voorbeeld of de oefenopdracht in paragraaf 1 en pas deze aan.
\end{itemize}

\pythonexternal{inc/h3/plt_vb2.py}

\subsection{Grafieken naast \'of onder elkaar}
Soms is het fijn om twee of meer plots onder elkaar of naast elkaar te laten zien. In onderstaand voorbeeld worden er 3 grafieken naast elkaar gemaakt in hetzelfde figuur. 

In plaats van \pythoninline{plt.subplots()} nu leeg te laten, voegen we in hoeveel grafieken we willen maken. De 1 betekent \'e\'en plot in de hoogte, 3 in de breedte. Zoals hiervoor wordt de hele figuur beschreven met \pythoninline{fig}. De losse grafieken noemen we \pythoninline{ax1, ax2} en \pythoninline{ax3}. Als je twee grafieken zou willen verander je de 3 in een 2, en moet je \pythoninline{ax3} verwijderen. Als je er vier zou willen, maak je van de 3 een 4 en voeg je een \pythoninline{ax4} toe.
\pythonexternal{inc/h3/plt_vb3.py}

\subsubsection*{Oefenopdracht: meer grafieken in een figuur}
\begin{itemize}
	\item[g)] Voer bovenstaand script ook uit en kijk hoe het eruit ziet. Wissel de 1 en 3 eens om en kijk wat er dan gebeurt!
	\item[h)] Het staat best lelijk dat de getallen op de y-as van het tweede en derde grafiekje overlappen met de vorige. Los dit op door de volgende aanpassing in de eerste regel:\\
	\pythoninline{fig, (ax1, ax2, ax3) = plt.subplots(1, 3, sharex=True, sharey=True)}\\
	Hiermee forceer je dat de x- en y-as van alle grafiekjes automatisch hetzelfde zijn en de getallen dus verdwijnen omdat ze overbodig zijn.
	\item[i)] Voeg ook aan het tweede en derde grafiekje een grid toe. Geef daarnaast elke plot een label en ook elk figuur een legenda. Let op: je moet elke handeling voor elke grafiek los doen, dus voor \pythoninline{ax1, ax2} en \pythoninline{ax3}.
\end{itemize}

\subsection{Grafieken naast \'en onder elkaar}
Het is uiteraard ook mogelijk om plots onder \'en naast elkaar te zetten. In het volgende voorbeeld worden 2 bij 2 plots gemaakt. Let op! De plots zitten nu niet meer in de losse namen \pythoninline{ax1, ax2} en \pythoninline{ax3}, maar ze zitten alle vier in de algemene naam \pythoninline{axarr}. Net zoals bij een array een plek opgegeven wordt met bijvoorbeeld \pythoninline{[1]}, kun je een specifiek plot ophalen met de blokhaken. Het eerste getal tussen de blokhaken staat daarbij voor de rij, het tweede getal voor de kolom. Zie het voorbeeld.

\pythonexternal{inc/h3/plt_vb4.py}

\subsubsection*{Oefenopdracht: opmaak van meer grafieken}
\begin{itemize}
	\item[j)] Voeg aan elke grafiek een grid toe. Let op dat je hier niet gebruik maakt van \pythoninline{ax1} etc., maar dat nu vervangt door \pythoninline{axarr[0,0]} etc.
\end{itemize}

\subsection{Slotopdracht: Heel veel plotjes}
\begin{itemize}
	\item Maak een figuur van 2-bij-2 plots waarin net als in bovenstaand voorbeeld \pythoninline{sharex} en \pythoninline{sharey} gebruikt worden.
	\item Maak een array \pythoninline{x} met een ruim aantal getallen, oplopend van 0 tot en met $\pi$ (niet random dus!). Hoeveel is genoeg? Denk terug aan de sinus met 10 of 100 getallen.
	\item Plot vervolgens per plot de volgende lijnen:\\
	1. $sin(x)$ en $cos(x)$\\
	2. $sin(x)^2$ en $cos(x)^2$\\
	3. $x^{0.5}$ en $x^2$\\
	4. $1/x$ en $log(x)$ (dit levert waarschuwingen op in de Console: die mag je negeren)\\
	De logaritme kun je plotten met behulp van \pythoninline{np.log(x)}.
	\item Zorg ervoor dat het bereik op de x-as (het domein) loopt van 0 tot $\pi$ voor alle plots.
	\item Voeg uiteindelijk ook labels en legenda's toe, en maak hem zo netjes mogelijk met de dingen die je in dit hoofdstuk geleerd hebt.
\end{itemize}


\clearpage
\renewcommand{\ditwc}{Importeren en exporteren}
\section[Importeren en exporteren]{\ditwc}
% Week 4
Voor het verwerken van data ben je eigenlijk altijd afhankelijk van losse bestanden die alle gegevens bevatten. Niemand gaat voor de lol duizenden getalletjes met de hand invoeren: dan kun je net zo goed Excel gebruiken. Ook wil je graag je gemaakte figuren en resultaten opslaan om ergens in te voegen: anders kun je net zo goed maar wat met de hand tekenen of berekenen. Maar daar doen we het niet voor: we gaan handelingen automatiseren door bestanden te \textit{importeren}, en vervolgens resultaten te \textit{exporteren}. Dat gaan we dit hoofdstuk behandelen.

\subsection{Afbeeldingen exporteren}
In het vorige hoofdstuk heb je al geleerd om plaatjes te maken. Figuren staan normaal gesproken alleen in Spyder, en kunnen niet direct gebruikt worden in een verslag, artikel of rapport. Daarvoor moet je de afbeelding eerst opslaan. Hiervoor kan je gebruik maken van \pythoninline{savefig()}.

{\it De standaard locatie waar de afbeelding wordt opgeslagen is de map waar het script is opgeslagen!}

De belangrijkste opties die je aan deze functie kunt meegegeven zijn de naam + bestandstype van de afbeelding, en de resolutie. De naam kun je uiteraard vrij kiezen; als bestandstype kan er worden gekozen voor \verb.jpg., \verb.png. en  \verb.pdf. (wij gebruiken hier alleen .png). 
De resolutie van deze afbeeldingen wordt gespecificeerd in \textit{dots-per-inch}  (\verb,dpi,). Een gemiddeld beeldscherm heeft zo'n 140 dpi, maar voor een plaatje is meer dpi zeker fijn.

Met behulp van \pythoninline{figsize=[breedte, hoogte]} kun je instellen hoe groot je plaatje is, en welke verhoudingen hij heeft. Hoe groter de breedte en hoogte, hoe groter het bestand. Deze functie kun je invoegen in \pythoninline{plt.subplots()}.

\pythonexternal{inc/h4/export_vb1.py}

\subsubsection*{Oefenopdracht: plots opslaan} 
\begin{itemize}
	\setlength\itemsep{0em}
	\item[a)] Open het bovenstaande voorbeeld-script \verb,export_vb1.py,. Maak verschillende plaatjes door de volgende instellingen te gebruiken:

	\begin{enumerate}
		\item Het aantal dots-per-inch. Kies bijv. 300 of 1200.
		\item De grootte van het plaatje. Kies bijv. \verb=[2,1]= of \verb=[20,10]=.
	\end{enumerate}

	\item[b)] Open de plaatjes en kijk naar de kwaliteit. Gebruik de zoom-functie! Kijk ook naar de bestandsgrootte (in kilobytes) van de aangemaakte bestanden. Trek je conclusie! (De plaatjes kun je vinden in dezelfde map als je script.)
	
	\item[c)] Sla de figuur van slotopdracht hoofdstuk 3 ook op.
\end{itemize}

\subsection{Bestanden importeren}
Net als bij het exporteren van gegevens voor later gebruik, moet er bij importeren een vertaalslag worden gemaakt om de gegevens uit een bestand om te zetten zodat deze bruikbaar zijn binnen Python. Daarvoor zijn allerlei instellingen, maar deze periode zien de bestanden er allemaal hetzelfde uit:

\begin{enumerate}
	\setlength\itemsep{0em}
	\item Het bestand bestaat uit regels (lines). Elke regel bevat of numerieke data of het is een commentaarregel.
	\item Elke regel bestaat uit \'e\'en of meerdere getallen die van elkaar gescheiden door komma's. Het scheidingsteken heet de \textit{delimiter}.
	\item Een commentaarregel is herkenbaar aan het \verb,#, teken op de eerste positie. Precies zoals in een Python script. Commentaarregels aan het begin van een bestand heten ook wel de {\it header}.
\end{enumerate}

Het inlezen van bestanden die numerieke data bevatten in de vorm van een array (rijen en kolommen) kan heel makkelijk gebeuren met de \pythoninline{numpy} functie \pythoninline{genfromtxt()}. Deze functie negeert regels die beginnen met een \verb,#, en dat komt goed uit, want dat is meestal toch vooral commentaar. Daarnaast kun je de {\it delimiter} specificeren, hier de komma dus. Het weergeven van bijvoorbeeld twee kolommen uit de ingelezen data in een $xy$-plot stelt dan weinig meer voor. Zie volgend voorbeeld:
 
\pythonexternal{inc/h4/genfromtxt_vb1.py}

\subsubsection*{Oefenopdracht: plotten van geïmporteerde data}
\begin{itemize}
	\setlength\itemsep{0em}
	\item[d)] Open bovenstaand script. Open ook \href{https://github.com/Ichthus-College-IN/Python-x-Meet-je-leefomgeving/blob/main/inc/h4/vb1.txt}{deze} link. Kopieer de inhoud ervan naar het programma Notepad, en sla het bestand op onder de naam \verb,vb1.txt,, {\it in dezelfde map als je script}! 
	\item[e)] Run het script, bekijk de werking en check in de Variable Explorer hoe de data eruitziet. Plot vervolgens $x$ en $y$ zoals je in het vorige hoofdstuk hebt gedaan.
\end{itemize}

\subsection{Slotopdracht: De weerstations van de KNMI}
In deze slotopdracht gaan we aan de slag met (gesimuleerde) meetdata van de KNMI. Het KNMI heeft in totaal 48 meetstations verspreid over Nederland. Elke paar seconden doet zo'n meetstation een meting en rapporteert de waarden naar de servers van de KNMI\footnote{Bron: \href{https://www.knmi.nl/kennis-en-datacentrum/uitleg/automatische-weerstations}{KNMI}}. Op basis hiervan worden allerlei voorspellingen gedaan, zoals het mooie overzicht dat Buienradar altijd maakt. De voorspellingen zijn niet altijd zo accuraat, maar daar kijken we hier niet naar: we zijn ge\"interesseerd in de gemeten data.

Elk meetstation rapporteert in deze opdracht gedurende vier dagen lang gemiddeld elke vier minuten de temperatuur, maar soms duurt het wat langer, soms wat korter, en soms is het internet wat trager dan anders. Dit heeft tot gevolg dat de gemeten waarden elke keer in een andere volgorde binnenkomen op de servers van de KNMI.

Aan jou de taak om de gemeten temperaturen te importeren, te sorteren, te visualiseren en als laatste te exporteren. Zo bereid je je al goed voor op de eindopdracht die hier erg op lijkt.

\subsubsection*{1: Importeren van data}
Bekijk het volgende bestand:
\href{https://github.com/Ichthus-College-IN/Python-x-Meet-je-leefomgeving/tree/main/inc/data_h4.txt}{data-h4}. Kopieer net zoals in de oefenopdracht de inhoud (je kunt een van de knoppen rechtsbovenin gebruiken om alles te kopi\"eren) en sla het (via Notepad weer) op onder de naam \verb,data-h4.txt, (wederom in dezelfde map als je script).

Gebruik \pythoninline{np.genfromtxt} met de komma als delimiter, zodat je de meetgegevens in het bestand kunt inlezen. ({\bf Tip:} gebruik het vorige voorbeeld.)

\subsubsection*{2: Sorteren op meetstation}
De data bestaat uit twee kolommen: de eerste bevat het nummer van het meetstation, de tweede de gemeten temperatuur. Elke vier opeenvolgende metingen zijn altijd van de vier verschillende weerstations: het kan niet voorkomen dat er eentje ontbreekt. Alleen de volgorde verschilt. Je wordt aangeraden om bij het sorteren gebruik te maken van \pythoninline{np.argsort()}. Hieronder een voorbeeld om een deel van de getallen te sorteren:

\begin{python}
# nummers van de meetstations
stat = np.array([1,4,3,2, 4,2,1,3])

# de temperaturen die bij de stations horen, op dezelfde volgorde
temp = np.array([20.0,20.5,22.6,21.2, 20.1,20.4,22.4,21.3])

volgorde = np.argsort(stat[0:4])
# [0 3 2 1] is de goede volgorde: het eerste getal staat in stat[0],
# het tweede getal in stat[3], het derde in stat[2] en vierde in stat[1]

# selecteer de 4 temperaturen die we gaan sorteren
selectie = temp[0:4]

# plaats op de originele plek de gesorteerde getallen terug
temp[0:4] = selectie[volgorde]
\end{python}

Dit stukje code sorteert vier waarden op basis van de nummers van de weerstations. In het bestand staan er echter bijna 1500 keer 4 metingen onder elkaar. Je zult dus elke keer de temperaturen moeten sorteren in blokjes van vier, en dan doorgaan naar de volgende vier. Denk hiervoor terug aan de slotopdracht van hoofdstuk 2: hoe selecteer je elke keer vier elementen?

Let op: nu schuif je niet telkens één plekje op, maar vier plekken. Maak daarom gebruik van de volgende regel:

\begin{python}
for i in range(4, 1 + len(data), 4):
# we starten bij 4 en gaan door tot en met het einde met stappen van 4
\end{python}

\subsubsection*{3: Reshapen van data}
Je data is nu gesorteerd, maar alles staat op \'e\'en rij achter elkaar. Om de data te kunnen plotten, moeten we nu de data zo aanpassen, dat je \'e\'en hele rij of kolom kunt selecteren waar alle temperaturen van \'e\'en weerstation staan. Daarvoor kun je goed gebruik maken van \pythoninline{np.reshape(rijen, kolommen)}:

\begin{python}
temp = temp.reshape(int(len(temp)/4), 4)
\end{python}

Dit is een best complexe regel: we zeggen dat de vorm van \pythoninline{temp} z\'o moet zijn dat er 4 kolommen naast elkaar staan, en het aantal rijen is het totaal aantal meetpunten gedeeld door 4, omdat er over 4 meetstations gemeten wordt. Per weerstation zijn er dus \pythoninline{len(temp) / 4} meetpunten. En omdat het aantal rijen een heel getal moet zijn, zeggen we specifiek dat het een \pythoninline{int} moet zijn.

\subsubsection*{4: Plotten per weerstation}
Maak nu per weerstation een plot van de temperatuur. Gebruik als $x$ een array van 0 tot 96 (uur) voor de vier dagen, met het aantal meetpunten van \'e\'en weerstation als het aantal getallen in dat array (hint: maak dus gebruik van \pythoninline{np.linspace()}!). Gebruik als $y$ uiteraard een kolom uit \pythoninline{temp}.

Plot vervolgens per meetstation de temperaturen van de vier dagen. Je hebt dus vier figuurtjes nodig! Je wordt aangeraden een 2-bij-2 subplot te pakken van het vorige hoofdstuk. Voeg als laatste wat opmaak toe en sla je figuur op!

\subsubsection*{BONUS}
Voor een bonuspunt plot je niet in de vier plotjes elk meetstation {\it afzonderlijk}, maar geef je per plotje de data weer van de weerstations voor \'e\'en dag. Linksboven dus de eerste dag van alle vier de weerstations, rechtsboven de tweede, enzovoorts. (Maximaal een 10 als cijfer voor deze opdracht.)

\clearpage
\renewcommand{\ditwc}{Functies}
\section[Functies]{\ditwc}
% week 5
Je script kun je automatiseren door variabelen en de handelingen die je vaak herhaalt, in een \textit{functie} te zetten (een functie te defini\"eren). Een functie is een stukje tekst dat aan de hand van input \'e\'en of meerdere handelingen kan doen.

Functies worden vaak gebruikt om te voorkomen dat blokken code meerdere keren in een script herhaald worden. 
Hiermee zorg je ervoor dat, wanneer er een aanpassing gedaan moet worden, dit maar op \'e\'en plek hoeft te gebeuren. 
Ook blijft je script overzichtelijk, ook al maak je hem steeds langer of complexer. 

\subsection{Constructie van functies}
We gebruiken de formule $y = a x^2+b x + c$ om de werking van \textit{functies} uit te leggen. In het script hieronder zie je een voorbeeld van een functie die de waarde van de formule bereken.

\begin{python}
def formule(a, b, c, x):
	y = a*x**2 + b*x + c   # bereken de formule
	return y               # geef de waarde terug
\end{python} 

Een Python functie begin je met het woord \pythoninline{def} ('definition'), gevolgd door de naam van de \textit{functie}. Daarna volgen tussen ronde haakjes de variabelen die door de functie moeten worden gebruikt als input en waar je in de formule mee rekent (bijvoorbeeld $a, b, c$ en $x$ in bovenstaand voorbeeld). De regel wordt afgesloten met een dubbele punt om aan te geven dat wat er op de volgende regels staat de echte inhoud is. 

Daarna komt de code van de \textit{functie} zelf. Let op dat de regels binnen een definitie een indent nodig hebben, net als bij de loops en if/else-statements.

Als laatste {\it kun} je de definitie afsluiten met een \pythoninline{return}, maar dat kan verschillen. \pythoninline{return} geeft de waarde terug die je erachter zet, in bovenstaand voorbeeld is dat de waarde van $y$. Als je wilt weten wat de uitkomst is, willen we de waarde van $y$ graag `terugkrijgen' en gebruik je \pythoninline{return}. Maar als je in een functie alleen zet dat er een lijn geplot moet worden in een grafiek, hoef je geen getal terug te krijgen o.i.d., en sla je deze regel over.

\subsection{Gebruik van functies}
Om een functie te gebruiken typ je de naam van de functie, met de waarden die je als input wilt gebruiken. Daarbij zijn er twee smaken:

\begin{itemize}
	\item[1.] Je geeft de argumenten op volgorde mee: de waarde van $a$ als eerste, etc.
	\item[2.] Of: je geeft specifiek de labels $a$, $b$, $c$ en $x$ aan en dan mag je elke volgorde aanhouden. Dit heet het gebruik maken van {\it keyword} argumenten (sleutelwoord).
\end{itemize}

Je kunt beide opties ook mengen tot een derde smaak:

\begin{itemize}
	\item[3.] Eerst komen de argumenten op volgorde, daarna {\it keyword} argumenten.
\end{itemize}

\begin{python}
	# we geven de variabelen mee op de normale volgorde:
	waarde = formule(3, 2, 5, 1)
	
	# we maken gebruik van keyword argumenten (specifieke volgorde):
	waarde = formule(x=1, a=3, b=2, c=5)
	
	# we mengen:
	waarde = formule(3, 2, x=1, c=5)
\end{python}

\subsubsection*{Oefenopdracht: Controleren van bovenstaande functie}
\begin{itemize}
	\item Controleer dat \pythoninline{formule(3, 2, 5, 1)} en  \pythoninline{formule(x=1, a=3, b=2, c=5)} dezelfde waarde opleveren. Welke? En dat een \pythoninline{formule(1, 3, 2, 5)} een andere waarde oplevert. (Maak gebruik van \pythoninline{print(waarde)} uiteraard.)
	\item Test ook \pythoninline{formule(x=5, 1, 3, 2)} en \pythoninline{formule(3, 2, x=1, c=5)}. Welke optie werkt er wel en welke niet?
\end{itemize}

\subsection{Lokale vs. globale variabelen}
Het bovenstaande voorbeeld toont \'e\'en waarde op het scherm. Kijk je in het scherm van de \textbf{Variable explorer}, dan zie je dat \verb.a., \verb.b., \verb.c. en \verb.x. daar niet voorkomen. Deze variabelen zijn alleen bekend binnen de functie \verb.formule. en heten lokale variabelen. 

Waarden van lokale variabelen kun je hooguit weergeven door ze te printen binnen een functie, maar dat wordt al snel irritant als zo'n functie duizend keer wordt aangeroepen. Je kunt ze verder niet gebruiken {\it buiten} de functie. Waarden van globale variabelen kun je wel gebruiken binnen een functie. Maar je kunt niet binnen een functie de waarde van een globale variabele veranderen. {\bf Tip:} zorg ervoor dat de namen van variabelen in een functie andere namen hebben dan de globale variabelen. Zo voorkom je verwarring.

\subsection{Defaultwaarde}
Sommige argumenten worden maar zelden gebruikt of juist altijd op dezelfde manier. Een plot van temperatuurverloop bijvoorbeeld is eigenlijk altijd prettiger te lezen m\'et gridlijnen. Maar het is wel fijn als je dit soms kunt aanpassen (in dit geval het grid onderdrukken). Daarvoor zijn defaultwaarden erg praktisch: je kunt een argument standaard een waarde toekennen in een functie, tenzij je het anders opgeeft. Zie volgend voorbeeld en oefenopdracht:

\pythonexternal{inc/h5/voorbeeld5_1.py}

\subsubsection*{Oefenopdracht: Defaultwaarde}
\begin{itemize}
	\item Test bovenstaand script met de volgende regels:
	\begin{python}
mijn_plot(x_arr,1,2)
mijn_plot(x_arr,1,2,True)
mijn_plot(x_arr,1,2,False)
	\end{python}
	Wat gebeurt er? Wat is de invloed van \pythoninline{True} en \pythoninline{False}?
\end{itemize}

\subsection{Slotopdracht: Eigen plotfunctie}
Als je met een bak data aan het werk bent, maak je vaak plots die (bijna) helemaal hetzelfde zijn, op de lijnen na. Daarom is het fijn om een standaardfunctie te hebben die je in elke opdracht opnieuw kunt gebruiken, en met behulp van argumenten aan te passen is naar hoe de specifieke opdracht. In deze opdracht heb je alle vrijheid, op \'e\'en regel na: je \pythoninline{mijn_plot}-functie begint met deze regel:

\begin{python}
def mijn_plot(x,y,i,j,label=None,xlabel=None,ylabel=None,
	      xmin=None,xmax=None,ymin=None,ymax=None,
	      legenda=False,grid=True):
\end{python}
Hier staat \pythoninline{x} voor het array voor de x-as, en \pythoninline{y} voor de lijn die je wilt plotten. \pythoninline{i} en \pythoninline{j} staan hier voor de subplot waarin je wilt plotten (denk bijvoorbeeld aan \pythoninline{axarr[i,j]}). Vervolgens komen de keyword-arguments: \pythoninline{label} staat voor het label van je lijn, \pythoninline{xlabel, ylabel} spreken voor zich. \pythoninline{xmin, xmax, ymin} en \pythoninline{ymax} staan voor het bereik op de x- en y-as.; \pythoninline{legenda} voor \pythoninline{ax.legend()} en \pythoninline{grid} voor \pythoninline{ax.grid()}.

\bigbreak
{\bf Tip:} maak gebruik van het voorbeeld in paragraaf 5.4 en breid deze uit voor alle opties in de \pythoninline{mijn_plot}-regel. Kijk terug naar paragraaf 3.2 als je niet alle opties meer helder hebt.

\bigbreak
{\bf Truc:} Als je \pythoninline{ax.set_xlim(None, None)} invoert, gebeurt er niks. Dus roep je de functie aan zonder een waarde voor \pythoninline{xmin, xmax} op te geven en je gebruikt in je functie gewoon \pythoninline{ax_set.xlim(xmin,xmax)}, gebeurt er niets; als je wel waardes meegeeft, wordt dat netjes ingevuld. Hetzelfde geldt voor \pythoninline{label, set_xlabel, set_ylabel, set_ylim}.

\bigbreak
Als {\it proof-of-concept} pak je je slotopdracht van hoofdstuk 4. Maak gebruik van jouw functie in deze slotopdracht om de data van elk weerstation te plotten.


\clearpage
\renewcommand{\ditwc}{Meet je leefomgeving}
\section[Meet je leefomgeving]{\ditwc}
Dit hoofdstuk is de klapper op de vuurpijl. De afgelopen weken heb je (helaas nog niet :( ) een kastje vol met sensoren mee naar huis gehad. Dit kastje heeft lange tijd data verzameld van jouw leefomgeving, en het is tijd dat we die data gaan verwerken. Niet toevallig dat we Python combineren met het Meet je leefomgeving-project. 

De sensorkastjes zijn op zichzelf best `dom': het enige wat ze doen is de sensoren uitlezen en de data versturen. Aan jou nu de taak om van deze data chocola te gaan maken: hoe was de temperatuur de afgelopen weken, hoeveel fijnstof is er rond jouw huis, en hoeveel lawaai maken jouw buren nou werkelijk?

De eerste vijf hoofdstukken hebben we geleerd hoe Python werkt, hoe je \pythoninline{numpy} en \pythoninline{matplotlib} kan gebruiken, data kan importeren en figuren kunt opslaan. Dat gaat nu allemaal samenkomen in de eindopdracht.

Dit hoofdstuk bevat geen nieuwe stof: in principe kun je alles wat je tot nu toe geleerd hebt combineren om de eindopdracht te maken. De informatie in dit hoofdstuk geeft jou vooral de nodige kennis om te weten wat voor data je nou werkelijk bekijkt en wat voor plaatjes je moet maken, en een enkele truc die specifiek voor dit project fijn is om te weten.

\subsection{De sensoren}
Het kastje meet een flink aantal dingen. We behandelen de sensoren hier \'e\'en voor \'e\'en met de bijbehorende informatie zoals eenheden (nuttig voor bijvoorbeeld de y-as!).

\subsubsection{ADC: accuspanning}
Het meest cruciale onderdeel is de accu. Hiervoor maken we geen gebruik van een fysieke sensor, maar van de ingebouwde
\begin{itemize}
	\item[0)] ADC: een Analog to Digital Converter. Een analoog signaal (de stroom) komt binnen bij de microcontroller, die een digitaal signaal berekent in Volt, die de spanning van de batterij aangeeft. Deze ligt typisch tussen de 4.7 en 3.4 V. Een vol opgeladen batterij levert 4.7 \`a 4.8V en naarmate die leegloopt gaat de spanning terug naar 3.4V waarna de batterij leeg is.
\end{itemize}

\subsubsection{BME280: temperatuur, luchtdruk en relatieve luchtvochtigheid}
Deze sensor zit flink verstopt in het kastje: het is de middelste van de paarse printplaatjes onder aan de voorkant. Deze sensor meet drie dingen:
\begin{itemize}
	\item[1)] Temperatuur, in graden Celsius (\textdegree C). Als het goed is gaat de temperatuur uiteraard elke dag op en neer.
	\item[2)] Luchtdruk, in hectopascal (hPa); de volledige naam is barometrische luchtdruk. Deze heeft meestal een waarde net iets boven de 1000 hPa, en kan door de dag of week heen wat op en neer gaan, maar niet zo hard als de temperatuur.
	\item[3)] Relatieve luchtvochtigheid, in procenten (\%). De luchtvochtigheid verschilt met het weer, en hangt een beetje af van de luchtdruk. Dit gaat dus ook wat op en neer, net als de luchtdruk. Een logische waarde hiervoor is rond de 50\%.
\end{itemize}

\subsubsection{MAX4466: geluidssterkte}
Deze chip zit links onderaan en heeft een gaatje ervoor aan de voorkant. Dat is voor een goede meting wel nodig, want deze chip meet:
\begin{itemize}
	\item[4)] Geluidssterkte, in decibel (dB). De chip zit wat naar achteren in het kastje zodat hopelijk de wind niet al teveel herrie maakt, maar het lawaai nog wel goed te meten is. Maar als het stormt zal dat waarschijnlijk best wat storing opleveren in je meting: goed om rekening mee te houden! Er is niet zomaar een gemiddeld waarde, maar het zal ergens tussen de 20 en 80 decibel liggen waarschijnlijk.
\end{itemize}

\subsubsection{TSL2591: lichtintensiteit}
Was het de afgelopen week groeizaam weer of ontbrak de zon? Voor een boer en onderzoekers een relevante vraag, en zodoende is deze blauwe chip linksbovenop toegevoegd, en die meet:
\begin{itemize}
	\item[5)] Lichtintensiteit, in Lux (lx). Deze waarde kan erg hard heen en weer gaan: in een klaslokaal is de lichtintensiteit een paar honderd lux, buiten op een bewolkte dag ongeveer 1000 lux, in daglicht 10 tot 20 kilolux (klx) en in volle zon loopt het zelfs op tot 100 klx. Maar: deze chip zit onder wat donker plastic, dus een zonnige dag betekent hier niet direct 100 klx.
\end{itemize}

\subsubsection{VEML6070: UV-intensiteit}
Gebroederlijk naast de lichtsensor zit een kleine paarse chip. Deze meet:
\begin{itemize}
	\item[6)] UV-intensiteit. Deze heeft geen logische grootheid en eenheid, maar daarover later meer. Een logische waarde voor deze sensor is tussen de 0 en 1000. Ook deze sensor heeft `last' van de donkere plastic cover.
\end{itemize}

\subsubsection{CJMCU-811: VOC en CO$_2$-gehalte}
Dit is de rechtse van de sensoren onder aan de voorkant met zijn eigen opening, en meet de luchtkwaliteit met betrekking tot:
\begin{itemize}
	\item[7)] VOC-gehalte in de lucht. VOC's zijn Vluchtige Organische Stoffen ({\it Volatile Organic Compounds}), gemeten in `parts per billion' (ppb). Ze zijn verantwoordelijk voor smog, verzuring en hebben een (kleine) invloed op klimaatverandering. Ze worden geproduceerd door sommige planten en bomen, maar ook door mensen bij het gebruik van bijvoorbeeld verf en spuitbussen. Tot 250 ppb is een gezond gehalte; bij een aanhoudend niveau van 250-2000 ppb gedurende een aantal dagen is het opletten, en een gehalte van meer dan 2000 ppb is erg schadelijk voor de gezondheid.\footnote{Bron: \href{https://www.airthings.com/what-is-voc}{https://www.airthings.com/what-is-voc}}
	\item[8)] CO$_2$-gehalte in de lucht. Dit wordt gemeten in `parts per million' (ppm): het aantal deeltjes dat per miljoen deeltjes in de lucht voorkomt. Gemiddeld lag dit in 2019 volgens Buienradar op 417 ppm. Uiteraard de grootste veroorzaker van het versterkte broeikaseffect. Hierover later nog een kanttekening.
\end{itemize}

\subsubsection{SDS011: fijnstof}
De grote metalen sensor onderin heeft ook een opening aan de voorkant, en een ventilator die je soms aan hoort slaan. Deze meet ook luchtkwaliteit, maar dan met betrekking tot fijnstof, in twee categori\"en:
\begin{itemize}
	\item[9)] PM$_{2,5}$ deeltjes ({\it particulate matter}): deeltjes met een diameter van minder dan 2,5 $\mu m$ (micrometer). Dat is het formaat van rookdeeltjes, of de diameter van een gemiddelde bacterie. De maximale toegestane waarde volgens de Wereldgezondheidorganisatie voor deze deeltjes is 10 $\mu g/m^3$. Dat is dan ook direct de eenheid waarin dit gemeten wordt.
	\item[10)] PM$_{10}$ deeltjes: deeltjes met een diameter van minder dan 10 $\mu m$. Dat is kleiner of gelijk aan het formaat van een mistdruppeltje. De maximaal toegestaan concentratie in de lucht volgens de WHO is 20 $\mu g/m^3$. 
\end{itemize}

\subsubsection{Ublox NEO-6M GPS6MU2: GPS}
Niet altijd is duidelijk waar precies je sensorkastje zich bevindt, of soms wil je een leuk overzichtje hebben van alle locaties. Daarom is ook de grote blauwe module met het metaal-roze blok bijgevoegd. Deze meet:
\begin{itemize}
	\item[11)] GPS-locatie, in NB-OL co\"ordinaten. Co\"ordinaten kun je echter niet zo makkelijk in een grafiekje weergeven, dus laten we dat hier achterwege. Mocht je de uitdaging aan willen gaan om GPS op een kaartje weer te geven is dat mogelijk, maar het valt wel buiten het doel van deze reader.
\end{itemize}

\subsection{Handige informatie}
Lees eerst de volgende paragraaf over de eindopdracht, en kom vervolgens hier terug voor hints over het opzetten van je script.

\subsubsection*{np.argsort()}
De data van het sensorkastje is ongesorteerd. De meetwaarden worden allemaal in \'e\'en keer verzonden en afhankelijk van het bereik, de kracht van de antenne en andere factoren komen de data allemaal net niet tegelijkertijd aan, en telkens in een andere volgorde. Om te sorteren kun je handig gebruik maken van \pythoninline{np.argsort()}; zie de slotopdracht van hoofdstuk 4.

Er zijn elf channels: 0 tot en met 10. Elke elf waarden kun je sorteren met behulp van deze nummers. {\it Hint: je kunt ook een deel van de data sorteren door bijvoorbeeld het volgende in te vullen: \pythoninline{np.argsort(data[1:4])}.}

\subsection{De eindopdracht}
Na het harde(?) werken om 5 hoofdstukken onder de knie te krijgen, ben je eindelijk klaar om de eindopdracht te maken. Deze opdracht luidt als volgt: 

{\bf Verwerk de data van jouw meetkastje tot drie figuren: \'e\'en figuur met alle data van de afgelopen maand, \'e\'en figuur met alle data van de afgelopen week, en \'e\'en figuur met de data van een dag naar keuze uit de afgelopen maand.}

Voltooi je deze opdracht, dan scoor je daarmee een 8. Verwerk je de volgende punten ook, dan scoor je daarmee 1 extra punt. Steek je extra veel moeite in effici\"entie, commentaar en/of opmaak, kun je daar 1 punt extra voor scoren.

De exacte puntenverdeling en de onderdelen die aanwezig moeten zijn staan vermeld in de rubric op GitHub: kijk deze nog eens door voor je begint en af en toe terwijl je bezig bent.

De data die je kunt gebruiken is hier te vinden: \href{https://github.com/Ichthus-College-IN/Python-x-Meet-je-leefomgeving/blob/main/inc/h6/data_h6.csv}{data\_h6.csv}. Let op: dit is een .csv bestand. Of je het opslaat als .csv of .txt bestand maakt niet echt uit, en ook het importeren is hetzelfde voor beide bestanden.

\bigbreak
{\bf Extra opgaven:}
\begin{itemize}
	\item De UV-index wordt vermeld als {\it maat}, zonder eenheid. Je kunt er in de praktijk dus eigenlijk weinig mee. De fabrikant heeft echter wel de matchende UV-{\it levels} bij vermeld. De plot van de UV-waarden is veel nuttiger als je deze levels of zones dus ook aangeeft. Maak daarbij gebruik van de volgende verdeling:
	\begin{itemize}
		\item[1)] "LOW": [0, 560],
		\item[2)] "MODERATE": [561, 1120],
		\item[3)] "HIGH": [1121, 1494],
		\item[4)] "VERY HIGH": [1495, 2054],
		\item[5)] "EXTREME": [2055, 9999] 
	\end{itemize}
	Maak zelf een bewuste keuze: welke regio's geef je aan? Ga je door tot 9999? En geef je ook de namen weer, of alleen met kleuren de zones? En als lijnen, of als gekleurde vlakken? Maak hierbij gebruik van internet om het mooi te maken!
	\item De CJMCU-811-sensor is eigenlijk een beetje nep. Hij meet inderdaad correct het VOC-gehalte in de lucht, maar eigenlijk helemaal geen CO$_2$. De sensor neemt aan dat alle VOC's van mensen afkomstig zijn, en berekent dus hoeveel mensen er aanwezig zouden zijn volgens de VOC-waarde. Vervolgens neemt hij de gemiddelde CO$_2$-productie van een mens, om te berekenen hoeveel CO$_2$ er misschien dan in de lucht zit. Maak het inzichtelijk dat de sensor je hier voor de nep houdt door beide lijnen in dezelfde plot (in een nieuw figuur) te zetten. Helemaal mooi is het als je een tweede y-as (aan de rechterkant) weet toe te voegen waardoor je de lijnen kunt schalen.
\end{itemize}


\clearpage
\renewcommand{\ditwc}{BONUS}
\section{BONUS}
\subsection{Voormalige slotopdracht H4: De Europese bananeninspectie}
We passen de stof van de hoofdstukken 1 tot en met 4 toe op de strenge Europese regelgeving voor bananen.

\subsubsection*{1: Importeren van data}
Bekijk het volgende bestand: 
\href{https://github.com/Ichthus-College-IN/Python-x-Meet-je-leefomgeving/tree/main/inc/data_h7.txt}{data-h7}.

Sla een kopie van dit bestand op in dezelfde map waar ook het Python-script staat dat dit bestand moet gaan lezen en bewerken.
Gebruik \pythoninline{np.genfromtxt} met de komma als \verb,delimiter,, zodat je de meetgegevens in het bestand kunt inlezen en die in een \verb,numpy,-array om kunt zetten.

\subsubsection*{2: Testen op dikte}
We zullen de offici\"ele criteria van de Europese Commissie aanhouden zoals vastgesteld in \emph{Commission Regulation (EC) No 2257/94}. Deze richtlijnen stellen dat de minimale lengte van een banaan $L_\textrm{min} = 14\,\textrm{cm}$ en de minimale dikte is $d_\textrm{min} = 27\,\textrm{mm}$. We passen nu nog geen criteria toe op de kromtestraal $R$ of de smetten op het oppervlak $A$.

Voor bananen uit bepaalde Europese grondgebieden (Madeira, de Azoren, de Algarve, Kreta en Laconi\"e) geldt vanwege klimaatfactoren het criterium op de lengte niet, maar mogen deze toch op de Europese markt verkocht worden. Ervan uitgaande dat de dataset gegenereerd bij Opdracht 1 betrekking heeft op bananen uit \'e\'en van deze regio's, bereken het percentage bananen wat zou worden afgekeurd.

\subsubsection*{3: Lengte en dikte}
Na onderzoek blijkt dat een slimme bananenhandelaar uit Portugal heeft geprobeerd om een partij bananen uit India als bananen afkomstig uit de Algarve te verkopen om zo de Europese regelgeving omtrent de lengte van een banaan te omzeilen. Toets de partij bananen nu niet enkel op dikte, maar ook op lengte. Hoeveel procent van de bananen wordt nu afgekeurd?

\subsubsection*{4: Klasseindeling}
Binnen de Europese richtlijnen worden bananen in Klassen ingedeeld. De ``Extra'' klasse bevat bananen van ``superieure kwaliteit''. Klasse I bananen is de standaardklasse en Klasse II bevat bananen met lelijke vorm. De bijbehorende criteria staan in de tabel hieronder.

Deel de bananen aan de hand van de criteria in bovenstaande tabel in in de verschillende klassen. Rapporteer voor de gegenereerde dataset hoeveel procent van de bananen in de Extra klasse, hoeveel in klasse I en hoeveel in klasse II worden ingedeeld, rapporteer ook hoeveel procent van de bananen afgekeurd is.\footnote{Het correcte antwoord ligt rond: 1.52$\pm$0.04\% Extra, 12.84$\pm$0.10\% Klasse I, 66.50$\pm$0.15\% Klass II en 19.13$\pm$0.13\% afgekeurd.} Controleer of de bepaalde percentages optellen tot 100\%.

\begin{table}[!ht]
	\centering
	\caption{Criteria gesteld aan Bananen in de Europese Unie, per Klasse.}
	\begin{tabular}{c c c c}
		&\textbf{Extra} & \textbf{I} & \textbf{II}\\
		\hline
		$d$ & $\geq 27\,\textrm{mm}$     &$\geq 27\,\textrm{mm}$    &$\geq 27\,\textrm{mm}$\\
		$L$ & $\geq 14\,\textrm{cm}$     &$\geq 14\,\textrm{cm}$    &$\geq 14\,\textrm{cm}$\\
		$R$ & $1.25 L \leq R \leq 1.3 L$ &$1.2 L \leq R \leq 1.4 L$ & geen\\
		$A$ & $\leq 1\,\textrm{cm}^2$    &$\leq 2\,\textrm{cm}^2$   & $\leq 4\,\textrm{cm}^2$\\
		\hline
	\end{tabular}
\end{table}

\subsection{Commentaar schrijven}
Meestal ben je zelf de gebruiker van de code die je schrijft, maar je moet dit toch leesbaar maken voor anderen. Niet alleen de docent moet het kunnen volgen om een cijfer te kunnen geven, maar als je code leert schrijven zonder commentaar dan is jouw code meteen compleet onbruikbaar voor anderen. Vuistregel bij het schrijven van commentaar is dat je wilt dat wanneer je over 2 jaar de code weer opent weinig moeite hebt om te achterhalen wat er waar gebeurt, en hoe je de code opnieuw kunt gebruiken.

De hoeveelheid commentaar is een persoonlijke keuze, maar met te weinig commentaar maak je je code onleesbaar en daarmee compleet onbruikbaar in de toekomst. Goed commentaar schrijven kost tijd, dus houd daar rekening mee tijdens het programmeren - het schrijven van goed commentaar is onderdeel van het schrijven van code, en een script is niet af voordat er goed commentaar bij staat. Het is handig om commentaar gaandeweg te schrijven, en niet pas op het eind. Dit maakt het oplossen van problemen makkelijker en is ook handig voor jezelf, want je weet juist op het moment dat je de code voor het eerst schrijft het best wat het doel van dat stukje is.
Veel commentaar is niet per se goed commentaar. Zorg dat je commentaar ook echt iets zegt en helpt te begrijpen waarom een stuk of regel code gebruikt wordt:
\begin{python}
	# slecht commentaar:
	x = x + 1         # verhoog x
	# nuttig commentaar:
	x = x + 1         # compenseer voor index 0
\end{python}

\textbf{Richtlijnen voor het schrijven van goed commentaar:}
\begin{itemize}
	\item Gebruik \textit{natuurlijke taal}, d.w.z. gebruik zinnen en schrijf voluit. Gebruik geen Python code in comments,\footnote{Tenzij het een stukje code is wat tijdelijk niet gebruikt wordt.} en definieer (\'o\'ok voor de hand liggende) symbolen als $F$, $g$ en $T$.
	\item Zet commentaar bij het toekennen van numerieke waardes; zeg bij welke grootheid (evt. met symbool tussen haakjes) ze horen en welke eenheid ze hebben.
\end{itemize}

\begin{python}
	g = 9.81      # gravitatie constante (g) in m/s^2
	v0 = 25       # snelheid (v) bij t=0 in m/s
	n = 100       # aantal punten voor berekening
\end{python}

\begin{itemize}
	\item Wanneer je \pythoninline{print()} of \pythoninline{input()} gebruikt, print dan niet alleen de waarde of variabele waarin je ge\"interesseerd bent, maar print ook een beschrijving met context over die waarde of een specifieke instructie voor wat de input betekent.
	\item Elke functie heeft minimaal een beschrijving van wat die doet, wat de input en output is en wat de eventuele \pythoninline{*args} zijn.
	\item Bovenaan het script staat een algemene beschrijving van het script en voor welke toepassingen deze geschikt is.
	\item Blokken commentaar (met \pythoninline{'''text'''}) worden gebruikt om lange stukken commentaar te geven, bijvoorbeeld bij de uitleg van een functie, of bovenaan het script.
	\item In-line commentaar (met \pythoninline{# text}) staat precies op de plek waar het relevant is, en staat bij voorkeur uitgelijnd rechts van de code om de leesbaarheid te verbeteren.
\end{itemize}

Dan een aantal richtlijnen die niet per se met commentaar te maken hebben, maar die wel de leesbaarheid van je script sterk kunnen vergroten:
\begin{itemize}
	\item Maak de regels niet te lang. In Spyder (en de meeste andere editors) kun je een verticale lijn laten weergeven na een specifiek aantal karakters.\footnote{Het is je vast al opgevallen dat bij programmeren standaard een font gekozen wordt waarbij alle letters even breed zijn, zoals \texttt{Courier New}.} Zorg dat regels code en commentaar niet (veel) langer worden dan tot die lijn. Bij Python is de conventie om deze na 79 karakters te zetten. Let op dat je door syntax niet zomaar een nieuwe regel kunt beginnen; dit heeft namelijk een betekenis binnen Python. Door gebruik van de juiste \textit{indentatie} kun je toch aan de 79-karakter-limiet voldoen.
	\item Gebruik \pythoninline{#\%\%} om \textit{cells} te maken die los te runnen zijn. Let op: bij goede modulaire code (waarbij de acties in functies staan) is dit juist niet altijd handig. Tijdens het ontwikkelen van de code kunnen cells wel uitermate handig zijn, zodat je bijvoorbeeld een tijdrovend deel van je code kunt overslaan (bijvoorbeeld het genereren of analyseren van data) terwijl je door werkt aan een ander stuk (bijvoorbeeld het plotten van data).
	\item Schrijf bovenaan elke cell wat er in die cell gebeurd (welke `titel' je de cell zou geven).
	\item Gebruik scheidingsmarkeringen tussen lange stukken code. Een lege regel tussen het importeren van packages en de start van de code, en een lege regel tussen het einde van een loop en het vervolg van de (niet ge\"indenteerde) code, of een stuk code gescheiden door een regel \pythoninline{#---------} geven het script een overzichtelijkere uitstraling en maken het daarmee beter leesbaar.
	\item Verkies leesbaarheid over snelheid.
\end{itemize}
\begin{python}
	# dit is goed leesbaar en makkelijk aan te passen:
	q=1
	w=2
	e=3
	r=4
	
	q,w,e,r = 1,2,3,4 # kan ook, maar is erg onoverzichtelijk
\end{python}


\subsection{Effici\"entie verbeteren}
De meest gebruiksvriendelijke code is natuurlijk ook snel, je wilt liever een paar seconden wachten op je resultaten dan een paar minuten. Binnen de programmeerwereld staat Python bekend als een langzame taal. De snelheid van code hangt af van (a) de effici\"entie van de code zelf, (b) de snelheid waarmee het script wordt omgezet in machine code, en (c) de snelheid van computer processing unit (CPU).\footnote{Hier gebruiken we `script' en `code' als synoniemen met de betekenis: de text die jij schrijft of gebruikt om een geprogrammeerde taak uit te (laten) voeren. In werkelijkheid is een script maar een deel van de code, want er zitten veel (basis) instructies achter de schermen, die wel deel zijn van de code, maar die je niet terug ziet in je script.} Python is een langzame taal omdat de vertaling tussen het script en de instructies die naar de CPU gaan (in \'e\'enen en nullen) gebeurt tijdens het runnen van het script; dit maakt Python een \textit{interpreting language}. Bij een \textit{compiling language} zoals C of C++ moet je een script eerst \textit{compilen} voordat het naar de CPU gestuurd kan worden. Dit compilen kost tijd, maar het daadwerkelijke runnen van de code gaat dan veel vlotter.

Het voordeel van een \textit{scripting language} zoals Python is dat het makkelijker te leren is. Daarnaast kun je door de directe interpretatie snel en makkelijk kleine dingen veranderen in de code en meteen het effect daarvan zien. \textit{"Python was not made to be fast, but to make developers fast."} - Sebastian Witowski (Software Engineer bij CERN)

Er zijn manieren om je Python code om te zetten in C-gecompileerde code, en zelfs om je Python code op meerdere processors tegelijk (parallel) te laten uitvoeren.\footnote{Normaal gebruikt Python maar 1 CPU-core tegelijk; ook als jouw computer dus 4 cores heeft gebruikt Python er maar 1, en voert dus alle instructies in serie uit.} Meer over deze methodes zul je vanzelf tegen komen als je meer complexe simulaties of berekeningen gaat doen tijdens je studie of onderzoek. Deze manier van optimalisatie is echter geen onderdeel van deze beginnerscursus.

Over de snelheid van je CPU heb je ook niet direct invloed; behalve door het kopen van een nieuwe computer, snellere CPU, of gebruik maken van een externe CPU op een computercluster. Om je code sneller te laten uitvoeren kijken we in deze sectie dus alleen naar hoe we het script z\'elf effici\"enter kunnen maken.

\subsubsection{Effici\"entie meten}
De makkelijkste manier om de snelheid van je code te meten is door de tijd te noteren aan het begin van je code, en nadat je code klaar is, en dan het verschil te nemen. Dit kan intern met het \pythoninline{time}.

\pythonexternal{inc/h7/time_vb1.py}

Deze methode werkt prima als je de totale run-tijd van je script wilt bepalen. Het is altijd handig als de gebruiker weet hoe lang een script ongeveer runt; als je dit gemeten hebt, zet dit dan ook in de beschrijving bovenaan het script.

\subsubsection*{Oefenopdracht}
\begin{enumerate}[label=(\alph*)]
	\item Run bovenstaande code. Welke methode is het snelst?
	\item Kijk in de Variable explorer, of typ \pythoninline{type(naam_variabele)} rechtstreeks in de console (rechtsonder, na de input promt \pythoninline{In [getal]:}) om de types van de output van beide methodes te vergelijken; deze zijn verschillend.
	
	Zet nu het resultaat van de snelste methode om in hetzelfde type als het langzaamste resultaat. (Hint: gebruik \pythoninline{a = list(a)} of \pythoninline{b = np.array(b)}.) Als je specifiek dit type (\pythoninline{list} of \pythoninline{np.array}) resultaat wilt, is dezelfde methode dan nog steeds het snelst?
	\item Run het script nu een aantal keer (je kunt dit automatiseren door er een loop omheen te zetten!). De runtime van beide methodes is elke keer een beetje anders. Bereken de gemiddelde runtime voor beide methodes.
\end{enumerate}

\subsubsection{Wanneer optimaliseren?}
Optimaliseren door gebruik te maken van het soort testen die hierboven beschreven worden kost vrijwel altijd meer tijd dan dat het oplevert. Het optimaliseren als doel op zich kan een leuke puzzel zijn, maar is meestal bijzaak.

Wanneer is optimaliseren dan een goed idee? Vuistregel is:

\qquad \textit{``First make it work. Then make it right. Then make it fast''} - Kent Beck

Het belangrijkste is dat je code werkt; dat je code doet wat je wilt dat die doet (niet alleen geen errors geeft, maar ook dat het fysisch correct ge\"implementeerd is) en dat de aannames en input correct zijn. Daarna kun je je code robuuster maken; bijvoorbeeld opvangen wat er gebeurd als er verkeerde input gegeven wordt, of als ergens onverhoopt een negatief getal uit komt terwijl dat fysisch niet kan. Hier valt ook onder dat je zorgt dat je code toekomst-bestendig is, dus dat er goed commentaar bij staat. Pas daarna, als allerlaatst, kun je de snelheid van je code proberen te verbeteren.

Voor een goede optimalisatie moet er eerst onderzocht worden waar de meeste tijd verloren gaat. De meeste tijdswinst kan vaak gewonnen worden op de knelpunten (\textit{bottle neck}) die nu het meest tijd kosten. Binnen programmeren wordt het zoeken naar optimalisatie-knelpunten \textit{profileren} genoemd. Er zijn verschillende functies en packages beschikbaar die helpen met het profileren van code; veel gebruikt zijn \pythoninline{cProfile} (vaak in combinatie met \pythoninline{pstats}) en \pythoninline{line_profiler}. Het gebruik van deze packages ligt buiten de leerdoelen van deze cursus; we geven hier slechts vast een paar handvatten en vuistregels.

Bij het zoeken naar \textit{bottlenecks} kan het zijn dat niet CPU, maar bijvoorbeeld het lezen/schrijven van/naar geheugen (\textit{disk I/O}) het meest tijd kost. Daarnaast is optimalisatie niet altijd gericht op de code het snelst uitvoeren, soms is het belangrijker dat er weinig werkgeheugen (RAM), hardeschijfruimte, netwerkverkeer, of zelfs energie gebruikt wordt. Optimalisatie in tijdseffici\"entie zijn dan niet altijd gewenst.

In sommige gevallen is optimaal gebruik van CPU wel belangrijk, bijvoorbeeld wanneer een model of berekening zo groot is dat deze op een extern CPU cluster uitgevoerd moet worden. In dat geval wil je wel zorgen dat je zo optimaal mogelijk gebruik maakt van de CPU-tijd die je toegewezen krijgt.

\subsubsection{Standaard snelle oplossingen}
Met het idee dat optimaliseren onnodig veel tijd kost in het achterhoofd; hier toch een aantal vuistregels die je aan kunt houden om de code die je schrijft in Python meteen wat sneller te maken:
\begin{itemize}
	\item Leesbaarheid gaat altijd boven snelheid.
	\item Gebruik ingebouwde functies (dit kan alleen als je weet dat ze bestaan, dus als je iets nieuws wilt doen, kijk altijd even of er al een functie voor bestaat)
	\begin{itemize}
		\item \pythoninline{len(x)} geeft de lengte van een variabele, dit is sneller dan zelf de lengte tellen in een loop
		\item \pythoninline{np.mean(x)} geeft een gemiddelde van alle waardes in x.
		\item \pythoninline{map(function,iterable)} voert de functie uit op elk element in de lijst (iterable). Dit is doorgaans sneller dan een loop.
		\item Voor een uitgebreide lijst aan standaard functies zie: \url{https://docs.python.org/3/library/functions.html}
	\end{itemize}
	\item Loops zijn langzaam; als je een loop kunt vervangen voor een bestaande functie of een direct statement is dit sneller.
	\item Gebruik numpy arrays voor berekeningen op het gehele array; hiermee kun je vaak loops ontwijken.
	\item Doe rekenkundige operaties binnen een functie i.p.v. een simpele versie van die functie meerdere malen aan te roepen. (\textit{Let op:} dit gaat soms ten koste van de modulariteit, omdat dit je functie minder veelzijdig maakt.)
	\item Als iets is in minder regels (actieve) code kan, is het vaak het snelst om dat te doen. (\textit{Let op:} dit gaat soms ten koste van de leesbaarheid, en dat is ongewenst; als je code slecht leesbaar is kost het je altijd meer tijd om die weer te ontcijferen, dan het je oplevert als die een paar milliseconden sneller runt.)
	\item Gebruik de nieuwste versie van python, en de nieuwste formats/technieken/functies.
	\item Tussentijds printen of wegschrijven naar file kost tijd. Tijdens de test-fase is het printen van tussentijdse resultaten erg nuttig; dit maakt het makkelijker om een mogelijke fout op te sporen. Als een stuk code eenmaal correct werkt is het een goed idee om die vele prints te deactiveren (door ze weg te halen of er tijdelijk een \pythoninline{#} voor te zetten). Bij lange scripts kan het t\'och handig zijn om af en toe een print te laten staan (of toe te voegen) zodat de gebruiker weet waar het script mee bezig is en niet is vastgelopen.
\end{itemize}

Voorbeelden van snellere en langzamere code:
\begin{python}
	#%% check op True/False
	if variable == True: #35.8ns
	if variable is True: #28.7ns
	if variable:         #20.6ns
	
	if variable == False: #35.1ns
	if variable is False: #26.9ns
	if not variable:      #19.8ns
	# Is dit voor jou de tijdswinst waard?
\end{python}

\begin{python}
	# 1000 operaties en 1 functie
	def kwadraat(number):
	return number**2
	kwadraten = [kwadraat(i) for i in range(1000)]
	# 1000x gemeten met time: 0.40 sec
	
	def compute_kwadraten():
	return [i**2 for i in range(1000)]
	# 1000x gemeten met time: 0.31 sec
\end{python}

\subsubsection*{Oefenopdracht: effici\"entie}
\begin{enumerate}[label=(\alph*)]
	\item Wat denk je dat sneller is: \pythoninline{a = np.arange(100)} of \pythoninline{b = [*range(100)]}? Test dit met \pythoninline{time}
\end{enumerate}

\end{document}